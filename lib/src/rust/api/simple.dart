// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `rust_log`, `table_has_columns`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ApkgParseResult`, `CardExt`, `DeckNotesResult`, `LOG_SINK`, `Note`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `initialize`

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

Stream<String> registerLogCallback() =>
    RustLib.instance.api.crateApiSimpleRegisterLogCallback();

Future<ExtractResult> extractApkg({
  required String apkgPath,
  required String baseDir,
}) => RustLib.instance.api.crateApiSimpleExtractApkg(
  apkgPath: apkgPath,
  baseDir: baseDir,
);

Future<SingleNoteResult> getDeckNote({
  required String sqlitePath,
  required PlatformInt64 noteId,
  required String version,
}) => RustLib.instance.api.crateApiSimpleGetDeckNote(
  sqlitePath: sqlitePath,
  noteId: noteId,
  version: version,
);

Future<BigInt> getCardCount({required String sqlitePath}) =>
    RustLib.instance.api.crateApiSimpleGetCardCount(sqlitePath: sqlitePath);

Future<BigInt> getCardCountFromDeck({
  required String appDocDir,
  required String md5,
}) => RustLib.instance.api.crateApiSimpleGetCardCountFromDeck(
  appDocDir: appDocDir,
  md5: md5,
);

Future<FsrsScheduleResult> updateCardScheduleSimple({
  required double stability,
  required double difficulty,
  required PlatformInt64 lastReview,
  required int rating,
  required PlatformInt64 now,
}) => RustLib.instance.api.crateApiSimpleUpdateCardScheduleSimple(
  stability: stability,
  difficulty: difficulty,
  lastReview: lastReview,
  rating: rating,
  now: now,
);

Future<FsrsScheduleResult> updateCardSchedule({
  required double stability,
  required double difficulty,
  required PlatformInt64 lastReview,
  required int rating,
  required PlatformInt64 now,
}) => RustLib.instance.api.crateApiSimpleUpdateCardSchedule(
  stability: stability,
  difficulty: difficulty,
  lastReview: lastReview,
  rating: rating,
  now: now,
);

class ExtractResult {
  final String dir;
  final String md5;
  final Map<String, String> mediaMap;
  final String version;

  const ExtractResult({
    required this.dir,
    required this.md5,
    required this.mediaMap,
    required this.version,
  });

  @override
  int get hashCode =>
      dir.hashCode ^ md5.hashCode ^ mediaMap.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExtractResult &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          md5 == other.md5 &&
          mediaMap == other.mediaMap &&
          version == other.version;
}

class FieldExt {
  final PlatformInt64 id;
  final PlatformInt64 notetypeId;
  final String name;
  final PlatformInt64 ord;

  const FieldExt({
    required this.id,
    required this.notetypeId,
    required this.name,
    required this.ord,
  });

  @override
  int get hashCode =>
      id.hashCode ^ notetypeId.hashCode ^ name.hashCode ^ ord.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FieldExt &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          notetypeId == other.notetypeId &&
          name == other.name &&
          ord == other.ord;
}

class FsrsScheduleResult {
  final PlatformInt64 due;
  final double stability;
  final double difficulty;

  const FsrsScheduleResult({
    required this.due,
    required this.stability,
    required this.difficulty,
  });

  @override
  int get hashCode => due.hashCode ^ stability.hashCode ^ difficulty.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FsrsScheduleResult &&
          runtimeType == other.runtimeType &&
          due == other.due &&
          stability == other.stability &&
          difficulty == other.difficulty;
}

class NoteExt {
  final PlatformInt64 id;
  final String guid;
  final PlatformInt64 mid;
  final List<String> flds;
  final String notetypeName;
  final List<String> fieldNames;

  const NoteExt({
    required this.id,
    required this.guid,
    required this.mid,
    required this.flds,
    required this.notetypeName,
    required this.fieldNames,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      guid.hashCode ^
      mid.hashCode ^
      flds.hashCode ^
      notetypeName.hashCode ^
      fieldNames.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NoteExt &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          guid == other.guid &&
          mid == other.mid &&
          flds == other.flds &&
          notetypeName == other.notetypeName &&
          fieldNames == other.fieldNames;
}

class NotetypeExt {
  final PlatformInt64 id;
  final String name;
  final String? config;

  const NotetypeExt({required this.id, required this.name, this.config});

  @override
  int get hashCode => id.hashCode ^ name.hashCode ^ config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NotetypeExt &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          config == other.config;
}

class SingleNoteResult {
  final NoteExt note;
  final NotetypeExt? notetype;
  final List<FieldExt> fields;
  final PlatformInt64 ord;
  final String front;
  final String back;
  final String css;

  const SingleNoteResult({
    required this.note,
    this.notetype,
    required this.fields,
    required this.ord,
    required this.front,
    required this.back,
    required this.css,
  });

  @override
  int get hashCode =>
      note.hashCode ^
      notetype.hashCode ^
      fields.hashCode ^
      ord.hashCode ^
      front.hashCode ^
      back.hashCode ^
      css.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SingleNoteResult &&
          runtimeType == other.runtimeType &&
          note == other.note &&
          notetype == other.notetype &&
          fields == other.fields &&
          ord == other.ord &&
          front == other.front &&
          back == other.back &&
          css == other.css;
}
